<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>oolib.js</title>
<link rel="stylesheet" type="text/css" href="stylesheets/style.css" />
<script type="text/javascript">
	var _gaq = _gaq || [];
	_gaq.push([ '_setAccount', 'UA-36489708-1' ]);
	_gaq.push([ '_trackPageview' ]);

	(function() {
		var ga = document.createElement('script');
		ga.type = 'text/javascript';
		ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl'
				: 'http://www')
				+ '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(ga, s);
	})();
</script>
</head>
<body>
	<div class="heading">
		<div class="nav">
			<a href="#guide">Guide</a> / <a href="#reference">Reference</a> / <a href="#comments">Comments</a>
		</div>
		<h1>oolib.js</h1>
		<h2>// The JavaScript OOP library</h2>
	</div>
	<div id="guide" class="article guide">
		<section>
			<h1>Overview</h1>
			<p>oolib.js is a tiny javascript library that provides an original solution to the age-old problem of JavaScript OOP encapsulation. It
				offers the following features:</p>
			<ul>
				<li>Real encapsulation of object fields and private methods.
				<li>Class inheritance. (The fields and private methods are accessible by the subclasses.)
				<li>Support of object initialization and deinitialization.
				<li>Super method call.
				<li>Intuitive syntax.
				<li>Good performance (no costly "magic"). Really tiny (only 1.6 kilobytes minified / 0.7 kilobytes gzipped).
			</ul>
		</section>
		<section>
			<h1>Getting started</h1>
			<p>
				Download the library from here: <a href="https://github.com/idya/oolib">https://github.com/idya/oolib</a>
			</p>
			<p>Include oolib.js into your HTML file with something like this:</p>
			<pre><code>&lt;script src='path/to/oolib.js'&gt;&lt;/script&gt;</code></pre>
			<p>
				This will create a global namespace object <code>oo</code>.
			</p>
			<p>The library is also provided as an A(synchronous) M(odule) D(efinition) module (RequireJS, curl.js, etc.), and as a CommonJS module
				(typically for server-side environments).</p>
		</section>
		<section>
			<h1>The basics</h1>
			<p>We can define a class (ie a constructor function) with the following syntax:</p>
			<pre><code>var MyClass = oo.createClass({

	_create: function(foo) {
		this.myField = foo;
	},
	_myPrivateMethod: function(bar) {
		return this.foo + bar;
	},
	myPublicMethod: function(baz) {
		return this._myPrivateMethod(baz);
	}
});</code></pre>
			<p>
				<code>_create</code> is the instance initialization method (we would call it a "constructor" is java), that is called automatically, when a
				new instance object is created. Let's create a new instance of this class:
			</p>
			<pre><code>var myObj = new MyClass(42);</code></pre>
			<p>
				Now here is the trick: we can <em>not</em> access the private methods (<code>_myPrivateMethod</code>, <code>_create</code>), nor the member
				fields (<code>myField</code>) through <code>myObj</code>. In fact, <code>myObj</code> has only a single member: <code>myPublicMethod</code>.
				If we call <code>myObj._myPrivateMethod()</code> or <code>myObj._create()</code>, we will get an exception; if we read <code>myObj._myField</code>,
				we will always get <code>undefined</code>.
			</p>
			<p>
				Actually, the object returned by the <code>new</code> operator (<code>myObj</code>) is <em>not</em> the real instance object; <code>myObj</code>
				is only a proxy object - I call it an "interface object" -, that contains proxy functions to the real public methods. The real instance
				object is hidden behind the curtains: it is <em>encapsulated</em>. Anyway, we can use <code>myObj</code> (the interface object) just as if
				it was the <em>real</em> instance object (with the exception of the <code>instanceof</code> operator; but we have a solution for that - keep
				reading).
			</p>
			<p>
				As you may have noticed, we use a naming convension here: if a method name starts with an underscore, it is considered private.<br>
				Fields are always considered private: we don’t have to start field names with an underscore.<br>Also, all of the <em>own</em> members
				of the (real) instance object (in the sense of <code>Object#hasOwnProperty</code>) are considered private.
			</p>
		</section>
		<section>
			<h1>Inheritance</h1>
			<p>We can define a subclass with the following syntax:</p>
			<pre><code>var MySubClass = oo.createClass(MyClass, {

	_myPrivateMethod: function(bar) {
		return this.foo + bar + 1;
	}
});</code></pre>
			<p>There is an alternative syntax for defining a subclass (a syntactic sugar):</p>
			<pre><code>var MySubClass = MyClass({

	_myPrivateMethod: function(bar) {
		return this.foo + bar + 1;
	}
});</code></pre>
			<p>The above two subclass definitions are completely equivalent.</p>
			<p>Subclasses can access the fields and the private methods of the superclass(es).</p>
			<section>
				<h2>Invoking overridden methods</h2>
				<p>
					We can invoke overridden superclass methods with <code>this._super(...)</code>. We have to supply the method name as the first parameter:
				</p>
				<pre><code>var MySubClass = MyClass({

	_myPrivateMethod: function(bar) {
		return this._super("_myPrivateMethod", bar) + 1;
	}
});</code></pre>
				<p>
					There is also <code>_superApply</code>; check the reference section.
				</p>
			</section>
		</section>
		<section>
			<h1>The oo.Base class</h1>
			<p>
				<code>oo.Base</code> is a class defined by the library, that we can use as a base class for our classes. It provides the following basic
				features:
			</p>
			<ul>
				<li>Instance initialization support.</li>
				<li>Instance deinitialization support.</li>
				<li>instanceof support.</li>
			</ul>
			<section>
				<h2>Instance initialization and deinitialization support</h2>
				<p>
					If we have an inheritance chain, and all the classes in the chain have a <code>_create</code> method, only one of them is invoked
					automatically when a new instance object is created (the <code>_create</code> method of the subclass at the end of the chain). Of course,
					we can invoke the overridden <code>_create</code> methods with <code>_super</code> - but we have to do it explicitly. That's where <code>oo.Base</code>
					comes to help: It implements <code>_create</code> in such a way, that it calls the <code>_init</code> methods of all the classes in the
					inheritance chain (if they exist) automatically.
				</p>
				<p>
					<code>oo.Base</code> also defines a public method called destroy. It implements <code>destroy</code> in such a way that it calls the <code>_dispose</code>
					methods of all the classes in the inheritance chain (if they exist) automatically.
				</p>
				<pre><code>var MyClass = oo.Base({

	_init: function(bar) {
		console.log("Initializing MyClass");
	},

	// define some other methods ...

	_dispose: function() {
		console.log("Deinitializing MyClass");
	}
});

var MySubClass = oo.MyClass({

	_init: function(bar) {
		console.log("Initializing MySubClass");
	},

	// define some other methods ...

	_dispose: function() {
		console.log("Deinitializing MySubClass");
	}
});

var myObj = new MySubClass(); // will invoke MyClass#_init, MySubClass#_init, in this order

// do some work with myObj ...

myObj.destroy(); // will invoke MySubClass#_dispose, MyClass#_dispose, in this order
</code></pre>
				<p>
					(The library itself does not implement any mechanisms to call the <code>destroy</code> method automatically.)
				</p>
				<p>
					There is also <code>_addDestroyFn</code>; check the reference section.
				</p>
			</section>
		</section>
		<section>
			<h1>instanceof support</h1>
			<p>Consider the following example:</p>
			<pre><code>var MyClass = oo.Base({

	// define some class members ...
});

var myObj = new MyClass();
 
var b = myObj instanceof MyClass; // returns false</code></pre>
			<p>
				<code>myObj instanceof MyClass</code> returns <code>false</code>, because <code>myObj</code> is not the <em>real</em> instance object, but
				only the interface object. So how can we check, if <code>myObj</code> is an interface object for <code>MyClass</code>? <br> <code>oo.Base</code>
				has an <code>isInstanceOf</code> method; so we can do
			</p>
			<pre><code>b = myObj.isInstanceOf(MyClass); // returns true</code></pre>
			<p>
				The library defines a marker interface class <code>oo.Interface</code>. All interface objects are instances of this class:
			</p>
			<pre><code>b = myObj instanceof oo.Interface; // returns true</code></pre>
			<p>
				And finally, the library provides a helper function <code>oo.isInterfaceOf</code>. With this function you we check, if an arbitrary object
				is an interface object for a class:
			</p>
			<pre><code>b = oo.isInterfaceOf(myObj, MyClass); // returns true</code></pre>
			<p>
				<code>oo.isInterfaceOf</code> works according to the following algorithm:
			</p>
			<ol>
				<li>It checks if <code>myObj</code> is an instance of the <code>oo.Interface</code> class. If not, it returns <code>false</code>.
				<li>It checks if <code>myObj</code> has a method named <code>isInstanceOf</code>. If not, it returns <code>undefined</code>.
				<li>It returns <code>myObj.isInstanceOf(MyClass)</code>.
			</ol>
		</section>
	</div>
	<div id="reference" class="article reference">
		<h1>Reference</h1>
		<section>
			<h3>
				function <em>oo.createClass(?BaseClass, members)</em>
			</h3>
			<p>Create a new class (a new constructor function).</p>
			<p>Parameters:</p>
			<dl>
				<dt>BaseClass (optional):
				<dd>The superclass (constructor function) to inherit from.
				<dt>members:
				<dd>An object literal (a map) defining the members of the new class. All non-function members are considered private. All function
					members with a name starting with a _ (underscore) are considered private.
			</dl>
			<p>
				An alternative syntax for creating a subclass: <code>MySubClass = MyBaseClass(members);</code>
			</p>
		</section>
		<section>
			<h3>
				field <em>iface</em>
			</h3>
			<p>This (private) field references the interface object (the proxy object) of the instance. It is set automatically when creating
				instances of the class.</p>
		</section>
		<section>
			<h3>
				abstract method <em>_create(…)</em>
			</h3>
			<p>
				The optional (private) instance initialization method that you can implement in your classes. It is called automatically when creating
				instances of the class. If a subclass overrides a superclass's <code>_create</code> method, only the subclass's <code>_create</code> method
				is called.<br>It gets the parameters that you pass when you invoke the constructor function with the <code>new</code> operator.
			</p>
			<p>
				(<code>_create</code> is implemented by <code>oo.Base.</code>)
			</p>
		</section>
		<section>
			<h3>
				method <em>_super(methodName, arg1, …, argN)</em>
			</h3>
			<p>
				A (private) method automatically defined for all classes created by oo.createClass(). The <code>_super</code> method calls the superclass
				method specified by the first parameter (as a string).<br>This is useful if you override a superclass method: with <code>_super</code>
				you can invoke the overridden method.
			</p>
		</section>
		<section>
			<h3>
				method <em>_superApply(methodName, argsArray)</em>
			</h3>
			<p>
				A (private) method automatically defined for all classes created by oo.createClass(). The <code>_superApply</code> method calls the
				superclass method specified by the first parameter (as a string).<br>This is useful if you override a superclass method: with <code>_superApply</code>
				you can invoke the overridden method.<br>Method parameters can be specified as an array.
			</p>
		</section>
		<section>
			<h3>
				class <em>oo.Interface</em>
			</h3>
			<p>A marker interface class for the interface (proxy) objects.</p>
		</section>
		<section>
			<h3>
				class <em>oo.Base</em>
			</h3>
			<p>A simple base class, provided by the library. It’s features are detailed in the next reference entries.</p>
		</section>
		<section>
			<h3>
				abstract method <em>_init(…)</em>
			</h3>
			<p>
				The optional (private) instance initialization method of the classes inherited from <code>oo.Base</code>, that you can implement in your
				classes. It is called automatically by <code>oo.Base</code>’s implementation of the <code>_create</code> method. In case of an inheritance
				chain, all the classes’ <code>_init</code> methods are called (starting from the superclasses).<br>It gets the parameters that you pass
				when you invoke the constructor function with the <code>new</code> operator.
			</p>
		</section>
		<section>
			<h3>
				method <em>oo.Base#destroy()</em>
			</h3>
			<p>A public method that you can call to deinitialize the object instance. (There is no automatic mechanism in the library to call this
				method).</p>
		</section>
		<section>
			<h3>
				abstract method <em>_dispose()</em>
			</h3>
			<p>
				The optional (private) instance deinitialization method of the classes inherited from <code>oo.Base</code>, that you can implement in your
				classes. It is called automatically by <code>oo.Base</code>’s implementation of the <code>destroy</code> method. In case of an inheritance
				chain, all the classes’ <code>_dispose</code> methods are called (starting from the subclasses).
			</p>
		</section>
		<section>
			<h3>
				method <em>oo.Base#_addDestroyFn(destroyFn)</em>
			</h3>
			<p>
				A (private) method that you can call to register a deinitializator function. The registered function will be called back automatically by <code>oo.Base</code>’s
				implementation of the <code>destroy</code> method.<br>The function call will be bound to the <em>real</em> instance object (ie the
				value of <code>this</code> will be the instance object.)
			</p>
			<p>
				Uses the (private) field <code>_destroyFns</code>, so please don't define a class member with that name.
			</p>
		</section>
		<section>
			<h3>
				method <em>oo.Base#isInstanceOf(MyClass)</em>
			</h3>
			<p>
				A public method that checks if the <em>real</em> instance object (not the interface object) is an instance of <code>MyClass</code>.
			</p>
		</section>
		<section>
			<h3>
				function <em>oo.isInterfaceOf(myObj, MyClass)</em>
			</h3>
			<p>
				Checks if <code>myObj</code> is an interface object (a proxy object) for the class <code>MyClass</code>. Useful only if <code>MyClass</code>
				is a subclass of <code>oo.Base</code> (or if <code>MyClass</code> implements the method <code>isInstanceOf</code>).
			</p>
		</section>
	</div>
	<div id="comments" class="article comments">
		<h1>Comments</h1>
		<section>
			<div id="disqus_thread"></div>
			<script type="text/javascript">
				/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
				var disqus_shortname = 'oolibjsdocs'; // required: replace example with your forum shortname

				/* * * DON'T EDIT BELOW THIS LINE * * */
				(function() {
					var dsq = document.createElement('script');
					dsq.type = 'text/javascript';
					dsq.async = true;
					dsq.src = 'http://' + disqus_shortname
							+ '.disqus.com/embed.js';
					(document.getElementsByTagName('head')[0] || document
							.getElementsByTagName('body')[0]).appendChild(dsq);
				})();
			</script>
			<noscript>
				Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
			</noscript>
			<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
		</section>
	</div>
</body>
</html>
